<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><title>Conway's Game of Life — Rainbow + Aging</title>
<style>
:root{--panel-bg:#f6f7f9;--panel-border:#e1e4e8;--accent:#2f6feb;--text:#111}
*{box-sizing:border-box}html,body{height:100%;margin:0;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
.app{height:100vh;display:flex;overflow:hidden}
.controls{width:260px;max-width:42vw;background:var(--panel-bg);border-right:1px solid var(--panel-border);padding:8px 10px;overflow:auto}
.controls h1{font-size:14px;margin:0 0 6px 0}
.group{margin-bottom:8px;padding-bottom:6px;border-bottom:1px dashed var(--panel-border)}
.row{display:flex;gap:6px;align-items:center;margin:3px 0;flex-wrap:wrap}
.row.tight{gap:4px;margin:2px 0}.row.stack{flex-direction:column;align-items:flex-start}
label{font-size:12px}
.inline{display:grid;grid-template-columns:auto 1fr auto;gap:4px 6px;align-items:center;width:100%}
input[type=number]{width:70px;padding:3px 5px;border:1px solid var(--panel-border);border-radius:6px;font-size:12px;background:#fff}
input[type=checkbox]{transform:translateY(1px);width:14px;height:14px}
.checkbox-row{display:grid;grid-template-columns:1fr auto;gap:2px 6px;width:100%}.checkbox-row label{align-self:center}
button{padding:5px 8px;border-radius:7px;border:1px solid var(--panel-border);background:#fff;font-size:12px;cursor:pointer;white-space:nowrap}
button.icon{padding:5px 6px}.primary{background:var(--accent);color:#fff;border-color:var(--accent)}button:disabled{opacity:.55;cursor:not-allowed}
.status{display:grid;grid-template-columns:1fr 1fr;gap:3px 6px;font-size:11px}.status div{white-space:nowrap}
.board-wrap{position:relative;flex:1;overflow:auto;background:#fff}canvas{display:block;image-rendering:pixelated;background:#fff}
.disabled-field{opacity:.6;pointer-events:none}
.fill-buttons{display:flex;gap:6px;align-items:center;flex-wrap:wrap}.fill-grid{display:grid;grid-template-columns:repeat(3,auto);gap:4px}.fill-grid button{font-size:15px;padding:3px 6px}
#btnFillColor{width:22px;height:22px;border-radius:5px;border:1px solid var(--panel-border);padding:0;overflow:hidden}
#btnFillColor::-webkit-color-swatch-wrapper{padding:0}#btnFillColor::-webkit-color-swatch{border:none}
#btnResizeFit{padding:4px 6px}
</style></head><body>
<div class="app"><aside class="controls">
  <h1>Conway's Game of Life</h1>
  <div class="group"><div class="row tight">
    <button id="btnPlay" class="primary" title="Play">Play</button>
    <button id="btnPause" title="Pause">Pause</button>
    <button id="btnStepBack" class="icon" title="Step back one generation">⬅️</button>
    <button id="btnStepForward" class="icon" title="Step forward one generation">➡️</button>
  </div></div>
  <div class="group"><div class="row inline">
    <label for="inputBlockSize">Block px</label><input id="inputBlockSize" type="number" min="1" step="1" value="15"/>
    <button id="btnResizeFit" title="Resize grid to fit available area with current block size">Resize</button>
  </div></div>
  <div class="group"><div class="row stack">
    <div class="checkbox-row"><label for="chkRainbow">Rainbow</label><input id="chkRainbow" type="checkbox"/></div>
    <div class="checkbox-row"><label for="chkTrends">Trends</label><input id="chkTrends" type="checkbox"/></div>
    <div class="checkbox-row"><label for="chkAging">Aging</label><input id="chkAging" type="checkbox"/></div>
    <div class="row inline" id="birthRateRow"><label for="inputBirthRate">Birth rate</label><input id="inputBirthRate" type="number" min="0" step="1" value="2"/></div>
    <div class="checkbox-row"><label for="chkPopRebal">PopRebal</label><input id="chkPopRebal" type="checkbox"/></div>
    <div class="row inline" id="thresholdRow"><label for="inputRebalThreshold">Threshold %</label><input id="inputRebalThreshold" type="number" min="0" max="100" step="1" value="5"/></div>
  </div>
  <div class="row inline"><label for="inputHistoryCap">History</label><input id="inputHistoryCap" type="number" min="1" max="500" step="1" value="20"/></div>
  <div class="checkbox-row"><label for="chkToroidal">Toroidal</label><input id="chkToroidal" type="checkbox" checked/></div></div>
  <div class="group">
    <div class="row inline"><label for="inputFillPercent">Fill %</label>
      <input id="inputFillPercent" type="number" min="0" max="100" step="1" value="10"/>
      <input id="btnFillColor" type="color" value="#007bff" title="Fill color (also used for manual drawing)"/>
    </div>
    <div class="fill-buttons"><span>Fill:</span><div class="fill-grid">
      <button id="btnFillNW" title="Fill top-left quarter">↖️</button>
      <button id="btnFillUp" title="Fill top half">⬆️</button>
      <button id="btnFillNE" title="Fill top-right quarter">↗️</button>
      <button id="btnFillLeft" title="Fill left half">⬅️</button>
      <button id="btnFillCenter" title="Fill entire board">⏺️</button>
      <button id="btnFillRight" title="Fill right half">➡️</button>
      <button id="btnFillSW" title="Fill bottom-left quarter">↙️</button>
      <button id="btnFillDown" title="Fill bottom half">⬇️</button>
      <button id="btnFillSE" title="Fill bottom-right quarter">↘️</button>
    </div></div>
    <div class="row tight"><button id="btnClear">Clear</button></div>
  </div>
  <div class="group"><div class="status">
    <div><strong>Generation:</strong> <span id="statGeneration">0</span></div>
    <div><strong>Live cells:</strong> <span id="statLive">0</span></div>
    <div><strong>Grid:</strong> <span id="statSize">0×0</span></div>
    <div><strong>Topology:</strong> <span id="statTopology">Toroidal</span></div>
    <div><strong>Live %:</strong> <span id="statLivePct">0%</span></div>
    <div><strong>FPS:</strong> <span id="statFPS">0</span></div>
  </div></div>
</aside><main class="board-wrap"><canvas id="board"></canvas></main></div>
<script>
(()=>{
const canvas=document.getElementById('board'),ctx=canvas.getContext('2d',{alpha:false});
const btnPlay=document.getElementById('btnPlay'),btnPause=document.getElementById('btnPause'),btnStepForward=document.getElementById('btnStepForward'),btnStepBack=document.getElementById('btnStepBack');
const btnFillUp=document.getElementById('btnFillUp'),btnFillDown=document.getElementById('btnFillDown'),btnFillLeft=document.getElementById('btnFillLeft'),btnFillRight=document.getElementById('btnFillRight'),btnFillCenter=document.getElementById('btnFillCenter'),btnFillNW=document.getElementById('btnFillNW'),btnFillNE=document.getElementById('btnFillNE'),btnFillSW=document.getElementById('btnFillSW'),btnFillSE=document.getElementById('btnFillSE');
const colorPicker=document.getElementById('btnFillColor'),btnClear=document.getElementById('btnClear'),btnResizeFit=document.getElementById('btnResizeFit');
const inputFillPercent=document.getElementById('inputFillPercent'),inputBlockSize=document.getElementById('inputBlockSize'),inputHistoryCap=document.getElementById('inputHistoryCap'),inputRebalThreshold=document.getElementById('inputRebalThreshold'),inputBirthRate=document.getElementById('inputBirthRate');
const chkToroidal=document.getElementById('chkToroidal'),chkRainbow=document.getElementById('chkRainbow'),chkTrends=document.getElementById('chkTrends'),chkAging=document.getElementById('chkAging'),chkPopRebal=document.getElementById('chkPopRebal');
const statGeneration=document.getElementById('statGeneration'),statLive=document.getElementById('statLive'),statSize=document.getElementById('statSize'),statTopology=document.getElementById('statTopology'),statLivePct=document.getElementById('statLivePct'),statFPS=document.getElementById('statFPS');
const boardWrap=document.querySelector('.board-wrap');
let historyCap=20,rows=0,cols=0,blockSize=15;
let grid=new Uint8Array(0),nextGrid=new Uint8Array(0);
let colR=new Uint8Array(0),colG=new Uint8Array(0),colB=new Uint8Array(0),nextR=new Uint8Array(0),nextG=new Uint8Array(0),nextB=new Uint8Array(0);
let generation=0,running=false,rafId=null,lastTickTime=null,lastFPS=0;
let history=[],cursor=-1,dragState=null,dirtySinceSnapshot=false;
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v)),idx=(r,c)=>r*cols+c,fmtPct=p=>(Math.round(p*10)/10).toFixed(1)+'%';
function setCanvasSizeToGrid(){canvas.width=cols*blockSize;canvas.height=rows*blockSize}
function computeFitGridDimensions(){const rect=boardWrap.getBoundingClientRect();const w=Math.max(0,Math.floor(rect.width)),h=Math.max(0,Math.floor(rect.height));return {newRows:Math.max(1,Math.floor(h/blockSize)),newCols:Math.max(1,Math.floor(w/blockSize))}}
function resizeGridToFit(keep=true){const {newRows,newCols}=computeFitGridDimensions();if(newRows===rows&&newCols===cols)return;const newSize=newRows*newCols;const newGrid=new Uint8Array(newSize),nr=new Uint8Array(newSize),ng=new Uint8Array(newSize),nb=new Uint8Array(newSize);if(keep&&grid.length){const cr=Math.min(rows,newRows),cc=Math.min(cols,newCols);for(let r=0;r<cr;r++)for(let c=0;c<cc;c++){const di=r*newCols+c,si=idx(r,c);newGrid[di]=grid[si];nr[di]=colR[si];ng[di]=colG[si];nb[di]=colB[si];}}rows=newRows;cols=newCols;grid=newGrid;nextGrid=new Uint8Array(newSize);colR=nr;colG=ng;colB=nb;nextR=new Uint8Array(newSize);nextG=new Uint8Array(newSize);nextB=new Uint8Array(newSize);setCanvasSizeToGrid();resetHistory();draw();updateStatus()}
function resetHistory(){history=[];cursor=-1;pushHistorySnapshot();updateHistoryButtons()}
function enforceHistoryCap(){while(history.length>historyCap){history.shift();cursor=Math.max(0,cursor-1)}updateHistoryButtons()}
function pushHistorySnapshot(){if(cursor<history.length-1)history=history.slice(0,cursor+1);history.push({grid:grid.slice(0),gen:generation,r:colR.slice(0),g:colG.slice(0),b:colB.slice(0)});enforceHistoryCap();cursor=history.length-1;updateHistoryButtons();dirtySinceSnapshot=false}
const canStepBack=()=>cursor>0,canStepForwardRedo=()=>cursor<history.length-1;
function loadHistoryAt(newCursor){if(newCursor<0||newCursor>=history.length)return;cursor=newCursor;const snap=history[cursor];if(snap.grid.length!==grid.length){grid=snap.grid.slice(0);colR=snap.r.slice(0);colG=snap.g.slice(0);colB=snap.b.slice(0);}else{grid.set(snap.grid);colR.set(snap.r);colG.set(snap.g);colB.set(snap.b);}generation=snap.gen;draw();updateStatus();updateHistoryButtons()}
function updateHistoryButtons(){btnStepBack.disabled=!canStepBack()||running;btnStepForward.disabled=running}
function setControlsForRunning(isRunning){running=isRunning;btnPlay.disabled=isRunning;btnPause.disabled=!isRunning;updateHistoryButtons()}
function updateStatus(){const live=countLive();statGeneration.textContent=String(generation);statSize.textContent=cols+'×'+rows;statTopology.textContent=chkToroidal.checked?'Toroidal':'Bounded';statLive.textContent=String(live);const total=rows*cols;pct=total?(live/total)*100:0;statLivePct.textContent=fmtPct(pct);statFPS.textContent=String(Math.round(lastFPS))}
function countLive(){let n=0;for(let i=0;i<grid.length;i++)n+=grid[i];return n}
function getFillRGB(){const hex=colorPicker.value;return [parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)]}
function neighborCountAndList(r,c){let sum=0;const tor=chkToroidal.checked,list=[];for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){if(!dr&&!dc)continue;let rr=r+dr,cc=c+dc;if(tor){if(rr<0)rr=rows-1;else if(rr>=rows)rr=0;if(cc<0)cc=cols-1;else if(cc>=cols)cc=0;const alive=grid[idx(rr,cc)];sum+=alive;if(alive)list.push(idx(rr,cc))}else{if(rr<0||rr>=rows||cc<0||cc>=cols)continue;const alive=grid[idx(rr,cc)];sum+=alive;if(alive)list.push(idx(rr,cc))}}return {sum,list}}
function computeNextGeneration(){for(let i=0;i<nextGrid.length;i++){nextGrid[i]=0;nextR[i]=colR[i];nextG[i]=colG[i];nextB[i]=colB[i]}for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){const i=idx(r,c),n=neighborCountAndList(r,c),alive=grid[i]===1;if(alive){nextGrid[i]=(n.sum===2||n.sum===3)?1:0}else if(n.sum===3){nextGrid[i]=1;if(chkRainbow.checked){let ar=0,ag=0,ab=0;for(let k=0;k<3;k++){const j=n.list[k];ar+=colR[j];ag+=colG[j];ab+=colB[j]}nextR[i]=Math.round(ar/3);nextG[i]=Math.round(ag/3);nextB[i]=Math.round(ab/3)}else{const [fr,fg,fb]=getFillRGB();nextR[i]=fr;nextG[i]=fg;nextB[i]=fb}}}}
function wrapOrBound(r,c){if(chkToroidal.checked){if(r<0)r=rows-1;else if(r>=rows)r=0;if(c<0)c=cols-1;else if(c>=cols)c=0;return {r,c,out:false}}else{if(r<0||r>=rows||c<0||c>=cols)return {r,c,out:true};return {r,c,out:false}}}
const indexAt=(r,c)=>r*cols+c;
function ringPositions(ci,rad){const cr=Math.floor(ci/cols),cc=ci%cols,pos=[];for(let dr=-rad;dr<=rad;dr++)for(let dc=-rad;dc<=rad;dc++){if(Math.max(Math.abs(dr),Math.abs(dc))!==rad)continue;let rr=cr+dr,cc2=cc+dc;const wp=wrapOrBound(rr,cc2);if(wp.out)continue;pos.push(indexAt(wp.r,wp.c))}return pos}
function spawnOneAtIncreasingRadius(ci,empty){const maxR=Math.max(rows,cols);for(let rad=1;rad<=maxR;rad++){const ring=ringPositions(ci,rad);if(!ring.length)continue;const j=ring[(Math.random()*ring.length)|0];if(empty[j])return j}return -1}
function getLivePct(){const total=rows*cols;return total?(countLive()/total)*100:0}
function getBR(){const v=Math.floor(Number(inputBirthRate.value));return (!isFinite(v)||v<0)?0:v}
function agingRespawnCount(){if(!chkAging.checked)return 0;const BR=getBR();if(chkPopRebal.checked){const cur=getLivePct(),target=clamp(parseFloat(inputFillPercent.value),0,100),thr=clamp(parseFloat(inputRebalThreshold.value),0,100);if(cur<target-thr)return BR+1;if(cur>target+thr)return Math.max(0,BR-1);return BR}else return BR}
function immediateNeighborAverageColorAt(i){const r=Math.floor(i/cols),c=i%cols;const n=neighborCountAndList(r,c);if(n.sum===0)return null;let ar=0,ag=0,ab=0;for(let k=0;k<n.list.length;k++){const j=n.list[k];ar+=colR[j];ag+=colG[j];ab+=colB[j]}return [Math.round(ar/n.list.length),Math.round(ag/n.list.length),Math.round(ab/n.list.length)]}
function applyAgingIfNeeded(){if(!chkAging.checked)return;if(history.length<Math.max(1,historyCap-1))return;const windowLen=Math.min(historyCap-1,history.length),snaps=[];for(let k=0;k<windowLen;k++)snaps.push(history[cursor-k]);const total=rows*cols,toKill=[];for(let i=0;i<total;i++){if(grid[i]!==1)continue;let all=true;for(let s=0;s<snaps.length;s++){if(snaps[s].grid[i]!==1){all=false;break}}if(all)toKill.push(i)}if(!toKill.length)return;const empty=new Array(total);for(let i=0;i<total;i++)empty[i]=(grid[i]===0);const nResp=agingRespawnCount(),[fr0,fg0,fb0]=getFillRGB();for(const i of toKill){const dR=colR[i],dG=colG[i],dB=colB[i];if(grid[i]===1){grid[i]=0;empty[i]=true}for(let k=0;k<nResp;k++){const j=spawnOneAtIncreasingRadius(i,empty);if(j<0)break;grid[j]=1;if(chkRainbow.checked){const avg=immediateNeighborAverageColorAt(j);if(avg){colR[j]=avg[0];colG[j]=avg[1];colB[j]=avg[2]}else{colR[j]=dR;colG[j]=dG;colB[j]=dB}}else{colR[j]=fr0;colG[j]=fg0;colB[j]=fb0}empty[j]=false}}}
function stepForwardComputeAndMutations(){computeNextGeneration();let t=grid;grid=nextGrid;nextGrid=t;t=colR;colR=nextR;nextR=t;t=colG;colG=nextG;nextG=t;t=colB;colB=nextB;nextB=t;generation++;applyAgingIfNeeded();draw();updateStatus()}
function snapshotIfDirty(){if(dirtySinceSnapshot)pushHistorySnapshot()}
function stepForwardUser(){if(!canStepForwardRedo()){snapshotIfDirty();stepForwardComputeAndMutations();pushHistorySnapshot()}else loadHistoryAt(cursor+1)}
function stepBackUser(){if(!canStepBack())return;loadHistoryAt(cursor-1)}
const lerp=(a,b,t)=>a+(b-a)*t,stops=[{p:0,c:[255,255,255]},{p:.15,c:[207,232,255]},{p:.30,c:[0,180,180]},{p:.50,c:[0,192,0]},{p:.75,c:[255,212,0]},{p:1,c:[255,0,0]}];
function colorFromFrac(f){f=Math.max(0,Math.min(1,f));if(f===0)return'rgb(255,255,255)';for(let i=0;i<stops.length-1;i++){const a=stops[i],b=stops[i+1];if(f>=a.p&&f<=b.p){const t=(f-a.p)/(b.p-a.p),r=Math.round(lerp(a.c[0],b.c[0],t)),g=Math.round(lerp(a.c[1],b.c[1],t)),bb=Math.round(lerp(a.c[2],b.c[2],t));return`rgb(${r},${g},${bb})`}}const last=stops[stops.length-1].c;return`rgb(${last[0]},${last[1]},${last[2]})`}
function drawTrendsLegend(x,y,w,h){const g=ctx.createLinearGradient(x,y,x+w,y);g.addColorStop(0,'rgb(255,255,255)');g.addColorStop(.15,'rgb(207,232,255)');g.addColorStop(.30,'rgb(0,180,180)');g.addColorStop(.50,'rgb(0,192,0)');g.addColorStop(.75,'rgb(255,212,0)');g.addColorStop(1,'rgb(255,0,0)');ctx.fillStyle=g;ctx.fillRect(x,y,w,h);ctx.strokeStyle='#333';ctx.strokeRect(x,y,w,h);ctx.fillStyle='#111';ctx.font='10px system-ui,sans-serif';ctx.textBaseline='top';for(const t of [0,25,50,75,100]){const tx=x+Math.round((t/100)*w);ctx.beginPath();ctx.moveTo(tx,y+h);ctx.lineTo(tx,y+h+4);ctx.stroke();const s=String(t)+'%';const tw=ctx.measureText(s).width;ctx.fillText(s,Math.min(Math.max(tx-tw/2,x),x+w-tw),y+h+4)}ctx.fillStyle='#111';ctx.font='11px system-ui,sans-serif';ctx.fillText('Trends',x,y-12)}
function draw(){const rainbowOn=chkRainbow.checked,wantTrends=chkTrends.checked,known=cursor+1;ctx.clearRect(0,0,canvas.width,canvas.height);if(wantTrends&&known>1){for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){const i=idx(r,c);let alive=0;for(let k=0;k<known;k++)alive+=history[cursor-k].grid[i];ctx.fillStyle=colorFromFrac(alive/known);ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize)}drawTrendsLegend(8,canvas.height-8-24,160,10)}else if(rainbowOn){for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){const i=idx(r,c);if(grid[i]){ctx.fillStyle=`rgb(${colR[i]},${colG[i]},${colB[i]})`;ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize)}}}else{for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){const i=idx(r,c);if(grid[i]){ctx.fillStyle=`rgb(${colR[i]},${colG[i]},${colB[i]})`;ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize)}}}if(blockSize>=16){ctx.strokeStyle='#eee';ctx.lineWidth=1;for(let c=0;c<=cols;c++){const x=c*blockSize+.5;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,rows*blockSize);ctx.stroke()}for(let r=0;r<=rows;r++){const y=r*blockSize+.5;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cols*blockSize,y);ctx.stroke()}}}
function randomIndicesInRegion(count,region){const {r0,r1,c0,c1}=region,cells=(r1-r0+1)*(c1-c0+1);count=Math.max(0,Math.min(count,cells));const chosen=new Set();while(chosen.size<count){const rr=r0+((Math.random()*(r1-r0+1))|0),cc=c0+((Math.random()*(c1-c0+1))|0);chosen.add(rr*cols+cc)}return chosen}
function fillRegionPct(pct,region){const {r0,r1,c0,c1}=region;if(r1<r0||c1<c0)return;const cells=(r1-r0+1)*(c1-c0+1),n=Math.round((pct/100)*cells);if(n<=0)return;const picks=randomIndicesInRegion(n,region),[fr,fg,fb]=getFillRGB();for(const i of picks){grid[i]=1;colR[i]=fr;colG[i]=fg;colB[i]=fb}dirtySinceSnapshot=true}
function doFillDirectional(which){const pctRaw=parseFloat(inputFillPercent.value),pct=clamp(isFinite(pctRaw)?pctRaw:0,0,100),midR=Math.floor(rows/2),midC=Math.floor(cols/2),regions={up:{r0:0,r1:Math.max(0,midR-1),c0:0,c1:cols-1},down:{r0:midR,r1:rows-1,c0:0,c1:cols-1},left:{r0:0,r1:rows-1,c0:0,c1:Math.max(0,midC-1)},right:{r0:0,r1:rows-1,c0:midC,c1:cols-1},center:{r0:0,r1:rows-1,c0:0,c1:cols-1},nw:{r0:0,r1:Math.max(0,midR-1),c0:0,c1:Math.max(0,midC-1)},ne:{r0:0,r1:Math.max(0,midR-1),c0:midC,c1:cols-1},sw:{r0:midR,r1:rows-1,c0:0,c1:Math.max(0,midC-1)},se:{r0:midR,r1:rows-1,c0:midC,c1:cols-1}};const region=regions[which];if(!region||region.r1<region.r0||region.c1<region.c0)return;pushHistorySnapshot();fillRegionPct(pct,region);draw();updateStatus()}
function doClear(){grid.fill(0);generation=0;history=[];cursor=-1;lastFPS=0;lastTickTime=null;dirtySinceSnapshot=false;pushHistorySnapshot();draw();updateStatus()}
function tick(time){if(!running)return;if(lastTickTime!=null){const dt=time-lastTickTime;if(dt>0)lastFPS=1000/dt}lastTickTime=time;stepForwardComputeAndMutations();pushHistorySnapshot();rafId=requestAnimationFrame(tick)}
function startPlay(){if(running)return;if(rafId)cancelAnimationFrame(rafId);setControlsForRunning(true);rafId=requestAnimationFrame(tick)}
function pausePlay(){if(!running)return;setControlsForRunning(false);if(rafId){cancelAnimationFrame(rafId);rafId=null}}
function eventToCell(ev){const rect=canvas.getBoundingClientRect(),x=ev.clientX-rect.left,y=ev.clientY-rect.top,c=Math.floor(x/blockSize),r=Math.floor(y/blockSize);if(r<0||r>=rows||c<0||c>=cols)return null;return {r,c,i:idx(r,c)}}
function handlePointerDown(ev){const cell=eventToCell(ev);if(!cell)return;const current=grid[cell.i],target=current?0:1;dragState=target;if(grid[cell.i]!==target){grid[cell.i]=target;if(target===1){const [fr,fg,fb]=getFillRGB();colR[cell.i]=fr;colG[cell.i]=fg;colB[cell.i]=fb}dirtySinceSnapshot=true;draw();updateStatus()}window.addEventListener('pointermove',handlePointerMove);window.addEventListener('pointerup',handlePointerUp,{once:true});canvas.setPointerCapture&&canvas.setPointerCapture(ev.pointerId||1)}
function handlePointerMove(ev){if(dragState===null)return;const cell=eventToCell(ev);if(!cell)return;if(grid[cell.i]!==dragState){grid[cell.i]=dragState;if(dragState===1){const [fr,fg,fb]=getFillRGB();colR[cell.i]=fr;colG[cell.i]=fg;colB[cell.i]=fb}dirtySinceSnapshot=true;draw();updateStatus()}}
function handlePointerUp(_ev){dragState=null;window.removeEventListener('pointermove',handlePointerMove);if(dirtySinceSnapshot)pushHistorySnapshot()}
function syncEnabledStates(){const agingOn=chkAging.checked;inputBirthRate.disabled=!agingOn;document.getElementById('birthRateRow').classList.toggle('disabled-field',!agingOn);const popOn=agingOn&&chkPopRebal.checked;inputRebalThreshold.disabled=!popOn;document.getElementById('thresholdRow').classList.toggle('disabled-field',!popOn);chkPopRebal.closest('.checkbox-row').classList.toggle('disabled-field',!agingOn)}
function init(){blockSize=clamp(parseInt(inputBlockSize.value,10)||15,1,4096);inputBlockSize.value=String(blockSize);historyCap=clamp(parseInt(inputHistoryCap.value,10)||20,1,500);inputHistoryCap.value=String(historyCap);resizeGridToFit(false);const total=rows*cols;if(total>0){const picks=Math.round(0.30*total),chosen=new Set(),[fr,fg,fb]=getFillRGB();while(chosen.size<picks)chosen.add((Math.random()*total)|0);for(const i of chosen){grid[i]=1;colR[i]=fr;colG[i]=fg;colB[i]=fb}}generation=0;lastFPS=0;lastTickTime=null;resetHistory();pushHistorySnapshot();document.getElementById('statTopology').textContent=chkToroidal.checked?'Toroidal':'Bounded';syncEnabledStates();draw();updateStatus()}
btnPlay.addEventListener('click',startPlay);btnPause.addEventListener('click',pausePlay);btnStepForward.addEventListener('click',()=>{if(!running)stepForwardUser()});btnStepBack.addEventListener('click',()=>{if(!running)stepBackUser()});
btnFillUp.addEventListener('click',()=>doFillDirectional('up'));btnFillDown.addEventListener('click',()=>doFillDirectional('down'));btnFillLeft.addEventListener('click',()=>doFillDirectional('left'));btnFillRight.addEventListener('click',()=>doFillDirectional('right'));btnFillCenter.addEventListener('click',()=>doFillDirectional('center'));btnFillNW.addEventListener('click',()=>doFillDirectional('nw'));btnFillNE.addEventListener('click',()=>doFillDirectional('ne'));btnFillSW.addEventListener('click',()=>doFillDirectional('sw'));btnFillSE.addEventListener('click',()=>doFillDirectional('se'));
btnClear.addEventListener('click',()=>{if(!running)doClear()});btnResizeFit.addEventListener('click',()=>{if(!running)resizeGridToFit(true)});
inputBlockSize.addEventListener('change',()=>{const v=Math.floor(Number(inputBlockSize.value));if(!isFinite(v)||v<1){inputBlockSize.value=String(blockSize);return}blockSize=v;resizeGridToFit(true)});
inputHistoryCap.addEventListener('change',()=>{const v=Math.floor(Number(inputHistoryCap.value));if(!isFinite(v)||v<1){inputHistoryCap.value=String(historyCap);return}historyCap=clamp(v,1,500);inputHistoryCap.value=String(historyCap);enforceHistoryCap();draw()});
chkToroidal.addEventListener('change',()=>{updateStatus();draw()});[chkRainbow,chkTrends,chkAging,chkPopRebal].forEach(el=>el.addEventListener('change',()=>{syncEnabledStates();draw()}));
window.addEventListener('resize',()=>{});canvas.addEventListener('pointerdown',handlePointerDown);
window.addEventListener('keydown',e=>{const tag=(e.target&&e.target.tagName)||'';const edit=(e.target&&(e.target.isContentEditable||tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT'));if(edit)return;if(e.code==='Space'){e.preventDefault();running?pausePlay():startPlay()}else if(e.code==='ArrowLeft'){e.preventDefault();if(!running)stepBackUser()}else if(e.code==='ArrowRight'){e.preventDefault();if(!running)stepForwardUser()}});
init();
})();
</script></body></html>