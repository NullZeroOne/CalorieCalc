<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conway's Game of Life — Rainbow + Aging</title>
  <style>
    :root { --panel-bg:#f6f7f9; --panel-border:#e1e4e8; --accent:#2f6feb; --text:#111; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .app{height:100vh;display:flex;overflow:hidden}
    .controls{width:310px;max-width:44vw;background:var(--panel-bg);border-right:1px solid var(--panel-border);padding:12px;overflow-y:auto}
    .controls h1{font-size:16px;margin:0 0 8px 0}
    .group{margin-bottom:10px;padding-bottom:8px;border-bottom:1px dashed var(--panel-border)}
    .row{display:flex;gap:8px;align-items:center;margin:4px 0;flex-wrap:wrap}
    .row.tight{gap:6px;margin:2px 0}
    .row.stack{flex-direction:column;align-items:flex-start}
    label{font-size:13px}
    .inline{display:grid;grid-template-columns:auto 1fr;gap:6px 8px;align-items:center;width:100%}
    input[type=number]{width:90px;padding:4px 6px;border:1px solid var(--panel-border);border-radius:6px;font-size:13px;background:#fff}
    input[type=checkbox]{transform:translateY(1px);width:16px;height:16px}
    .checkbox-row{display:grid;grid-template-columns:1fr auto;gap:2px 8px;width:100%}
    .checkbox-row label{align-self:center}
    button{padding:6px 10px;border-radius:8px;border:1px solid var(--panel-border);background:#fff;font-size:13px;cursor:pointer;white-space:nowrap}
    button.icon{padding:6px 8px}
    button.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
    button:disabled{opacity:.55;cursor:not-allowed}
    .status{display:grid;grid-template-columns:1fr 1fr;gap:4px 8px;font-size:12px}
    .status div{white-space:nowrap}
    .board-wrap{position:relative;flex:1;overflow:auto;background:#fff}
    canvas{display:block;image-rendering:pixelated;background:#fff}
    .disabled-field{opacity:.6;pointer-events:none}
    .fill-buttons button{font-size:16px;padding:4px 8px}
    #btnFillColor{width:28px;height:28px;border-radius:6px;border:1px solid var(--panel-border);padding:0;overflow:hidden}
    #btnFillColor::-webkit-color-swatch-wrapper{padding:0}
    #btnFillColor::-webkit-color-swatch{border:none}
    .legend{position:absolute;left:8px;bottom:8px;background:rgba(255,255,255,0.8);border:1px solid #ddd;border-radius:6px;padding:6px 8px;font-size:11px;color:#111}
  </style>
</head>
<body>
  <div class="app">
    <aside class="controls" aria-label="Controls">
      <h1>Conway's Game of Life</h1>
      <div class="group">
        <div class="row tight">
          <button id="btnPlay" class="primary" title="Play">Play</button>
          <button id="btnPause" title="Pause">Pause</button>
          <button id="btnStepBack" class="icon" title="Step back one generation">⬅️</button>
          <button id="btnStepForward" class="icon" title="Step forward one generation">➡️</button>
        </div>
      </div>

      <div class="group">
        <div class="row inline">
          <label for="inputBlockSize">Block px</label>
          <input id="inputBlockSize" type="number" min="1" step="1" value="3"/>
          <span></span>
          <button id="btnResizeFit" title="Resize grid to fit available area with current block size">Resize</button>
        </div>
      </div>

      <div class="group">
        <div class="row stack">
          <div class="checkbox-row"><label for="chkRainbow" title="Color births by averaging the 3 neighbors.">Rainbow</label><input id="chkRainbow" type="checkbox"/></div>
          <div class="checkbox-row"><label for="chkTrends" title="Show trend (white→blue→teal→green→yellow→red).">Trends</label><input id="chkTrends" type="checkbox"/></div>
          <div class="checkbox-row"><label for="chkAging" title="Cells alive across full history window die and respawn outward.">Aging</label><input id="chkAging" type="checkbox"/></div>
          <div class="row inline" id="birthRateRow"><label for="inputBirthRate" title="Number of cells to spawn per aged death (base value).">Birth rate</label><input id="inputBirthRate" type="number" min="0" step="1" value="2"/></div>
          <div class="checkbox-row"><label for="chkPopRebal" title="(Requires Aging) Adjust respawns based on Live% vs Fill% ± Threshold%.">PopRebal</label><input id="chkPopRebal" type="checkbox"/></div>
          <div class="row inline" id="thresholdRow"><label for="inputRebalThreshold" title="Deadzone for PopRebal (requires Aging).">Threshold %</label><input id="inputRebalThreshold" type="number" min="0" max="100" step="1" value="5"/></div>
          <div class="checkbox-row"><label for="chkBWColor" title="When Rainbow is OFF, show stored per-cell colors instead of black.">Colorize B/W</label><input id="chkBWColor" type="checkbox"/></div>
        </div>
        <div class="row inline"><label for="inputHistoryCap">History</label><input id="inputHistoryCap" type="number" min="1" max="500" step="1" value="10"/></div>
        <div class="checkbox-row"><label for="chkToroidal">Toroidal</label><input id="chkToroidal" type="checkbox" checked/></div>
      </div>

      <div class="group" aria-label="Fill & clear">
        <div class="row inline">
          <label for="inputFillPercent">Fill %</label>
          <input id="inputFillPercent" type="number" min="0" max="100" step="1" value="30" />
        </div>
        <div class="row fill-buttons">
          <span>Fill:</span>
          <button id="btnFillNW" title="Fill top-left quarter">↖️</button>
          <button id="btnFillUp" title="Fill top half">⬆️</button>
          <button id="btnFillNE" title="Fill top-right quarter">↗️</button>
          <button id="btnFillLeft" title="Fill left half">⬅️</button>
          <button id="btnFillCenter" title="Fill entire board">⏺️</button>
          <button id="btnFillRight" title="Fill right half">➡️</button>
          <button id="btnFillSW" title="Fill bottom-left quarter">↙️</button>
          <button id="btnFillDown" title="Fill bottom half">⬇️</button>
          <button id="btnFillSE" title="Fill bottom-right quarter">↘️</button>
          <input id="btnFillColor" type="color" value="#007bff" title="Fill color (also used for manual drawing)"/>
        </div>
        <div class="row tight"><button id="btnClear">Clear</button></div>
      </div>

      <div class="group">
        <div class="status">
          <div><strong>Generation:</strong> <span id="statGeneration">0</span></div>
          <div><strong>Live cells:</strong> <span id="statLive">0</span></div>
          <div><strong>Grid:</strong> <span id="statSize">0×0</span></div>
          <div><strong>Topology:</strong> <span id="statTopology">Toroidal</span></div>
          <div><strong>Live %:</strong> <span id="statLivePct">0%</span></div>
          <div><strong>FPS:</strong> <span id="statFPS">0</span></div>
        </div>
      </div>
    </aside>

    <main class="board-wrap">
      <canvas id="board" aria-label="Game board"></canvas>
    </main>
  </div>

  <script>
  (()=>{
    const canvas=document.getElementById('board');
    const ctx=canvas.getContext('2d',{alpha:false});
    const btnPlay=document.getElementById('btnPlay');
    const btnPause=document.getElementById('btnPause');
    const btnStepForward=document.getElementById('btnStepForward');
    const btnStepBack=document.getElementById('btnStepBack');
    const btnFillUp=document.getElementById('btnFillUp');
    const btnFillDown=document.getElementById('btnFillDown');
    const btnFillLeft=document.getElementById('btnFillLeft');
    const btnFillRight=document.getElementById('btnFillRight');
    const btnFillCenter=document.getElementById('btnFillCenter');
    const btnFillNW=document.getElementById('btnFillNW');
    const btnFillNE=document.getElementById('btnFillNE');
    const btnFillSW=document.getElementById('btnFillSW');
    const btnFillSE=document.getElementById('btnFillSE');
    const colorPicker=document.getElementById('btnFillColor');
    const btnClear=document.getElementById('btnClear');
    const btnResizeFit=document.getElementById('btnResizeFit');
    const inputFillPercent=document.getElementById('inputFillPercent');
    const inputBlockSize=document.getElementById('inputBlockSize');
    const inputHistoryCap=document.getElementById('inputHistoryCap');
    const inputRebalThreshold=document.getElementById('inputRebalThreshold');
    const inputBirthRate=document.getElementById('inputBirthRate');
    const chkToroidal=document.getElementById('chkToroidal');
    const chkRainbow=document.getElementById('chkRainbow');
    const chkTrends=document.getElementById('chkTrends');
    const chkAging=document.getElementById('chkAging');
    const chkPopRebal=document.getElementById('chkPopRebal');
    const chkBWColor=document.getElementById('chkBWColor');

    const statGeneration=document.getElementById('statGeneration');
    const statLive=document.getElementById('statLive');
    const statSize=document.getElementById('statSize');
    const statTopology=document.getElementById('statTopology');
    const statLivePct=document.getElementById('statLivePct');
    const statFPS=document.getElementById('statFPS');
    const boardWrap=document.querySelector('.board-wrap');

    let historyCap=10;
    let rows=0,cols=0;
    let blockSize=3;
    let grid=new Uint8Array(0);
    let nextGrid=new Uint8Array(0);
    // Store per-cell color always
    let colR=new Uint8Array(0), colG=new Uint8Array(0), colB=new Uint8Array(0);
    let nextR=new Uint8Array(0), nextG=new Uint8Array(0), nextB=new Uint8Array(0);

    let generation=0;
    let running=false;
    let rafId=null;
    let lastTickTime=null; // for FPS
    let lastFPS=0;

    // history holds snapshots of grid + colors
    let history=[];
    let cursor=-1;
    let dragState=null; // null | 0 | 1
    let dirtySinceSnapshot=false; // track unsnapshotted edits

    const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
    const idx=(r,c)=>r*cols+c;
    const fmtPct=p=>(Math.round(p*10)/10).toFixed(1)+'%';
    function setCanvasSizeToGrid(){canvas.width=cols*blockSize;canvas.height=rows*blockSize;}
    function computeFitGridDimensions(){
      const rect=boardWrap.getBoundingClientRect();
      const w=Math.max(0,Math.floor(rect.width));
      const h=Math.max(0,Math.floor(rect.height));
      return {newRows:Math.max(1,Math.floor(h/blockSize)),newCols:Math.max(1,Math.floor(w/blockSize))};
    }
    function resizeGridToFit(keep=true){
      const {newRows,newCols}=computeFitGridDimensions();
      if(newRows===rows&&newCols===cols)return;
      const newSize=newRows*newCols;
      const newGrid=new Uint8Array(newSize);
      const nr=new Uint8Array(newSize), ng=new Uint8Array(newSize), nb=new Uint8Array(newSize);
      if(keep&&grid.length){
        const cr=Math.min(rows,newRows),cc=Math.min(cols,newCols);
        for(let r=0;r<cr;r++){for(let c=0;c<cc;c++){const di=r*newCols+c, si=idx(r,c);newGrid[di]=grid[si];nr[di]=colR[si];ng[di]=colG[si];nb[di]=colB[si];}}
      }
      rows=newRows;cols=newCols;grid=newGrid;nextGrid=new Uint8Array(newSize);
      colR=nr; colG=ng; colB=nb; nextR=new Uint8Array(newSize); nextG=new Uint8Array(newSize); nextB=new Uint8Array(newSize);
      setCanvasSizeToGrid();resetHistory();draw();updateStatus();
    }
    function resetHistory(){history=[];cursor=-1;pushHistorySnapshot();updateHistoryButtons();}
    function enforceHistoryCap(){while(history.length>historyCap){history.shift();cursor=Math.max(0,cursor-1);}updateHistoryButtons();}
    function pushHistorySnapshot(){
      if(cursor<history.length-1){history=history.slice(0,cursor+1);} // drop redo
      history.push({grid:grid.slice(0), gen:generation, r:colR.slice(0), g:colG.slice(0), b:colB.slice(0)});
      enforceHistoryCap();cursor=history.length-1;updateHistoryButtons();
      dirtySinceSnapshot=false;
    }
    const canStepBack=()=>cursor>0;
    const canStepForwardRedo=()=>cursor<history.length-1;
    function loadHistoryAt(newCursor){
      if(newCursor<0||newCursor>=history.length)return;
      cursor=newCursor;const snap=history[cursor];
      if(snap.grid.length!==grid.length){grid=snap.grid.slice(0);colR=snap.r.slice(0);colG=snap.g.slice(0);colB=snap.b.slice(0);}
      else{grid.set(snap.grid);colR.set(snap.r);colG.set(snap.g);colB.set(snap.b);}
      generation=snap.gen;draw();updateStatus();updateHistoryButtons();
    }
    function updateHistoryButtons(){btnStepBack.disabled=!canStepBack()||running;btnStepForward.disabled=running;}
    function setControlsForRunning(isRunning){running=isRunning;btnPlay.disabled=isRunning;btnPause.disabled=!isRunning;updateHistoryButtons();}
    function updateStatus(){
      const live=countLive();statGeneration.textContent=String(generation);
      statSize.textContent=cols+'×'+rows;statTopology.textContent=chkToroidal.checked?'Toroidal':'Bounded';
      statLive.textContent=String(live);const total=rows*cols;const pct=total?(live/total)*100:0;statLivePct.textContent=fmtPct(pct);
      statFPS.textContent=String(Math.round(lastFPS));
    }
    function countLive(){let n=0;for(let i=0;i<grid.length;i++)n+=grid[i];return n;}
    function getFillRGB(){const hex=colorPicker.value;const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);return [r,g,b];}

    function neighborCountAndList(r,c){
      let sum=0;const tor=chkToroidal.checked; const list=[];
      for(let dr=-1;dr<=1;dr++){for(let dc=-1;dc<=1;dc++){if(dr===0&&dc===0)continue;let rr=r+dr,cc=c+dc;
        if(tor){if(rr<0)rr=rows-1;else if(rr>=rows)rr=0; if(cc<0)cc=cols-1;else if(cc>=cols)cc=0; const alive=grid[idx(rr,cc)]; sum+=alive; if(alive) list.push(idx(rr,cc));}
        else{if(rr<0||rr>=rows||cc<0||cc>=cols)continue; const alive=grid[idx(rr,cc)]; sum+=alive; if(alive) list.push(idx(rr,cc));}}}
      return {sum,list};
    }
    function computeNextGeneration(){
      // Writes into nextGrid/nextR/nextG/nextB
      for(let i=0;i<nextGrid.length;i++){nextGrid[i]=0; nextR[i]=colR[i]; nextG[i]=colG[i]; nextB[i]=colB[i];}
      for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){const i=idx(r,c);const {sum,list}=neighborCountAndList(r,c);const alive=grid[i]===1;
        if(alive){
          nextGrid[i]=(sum===2||sum===3)?1:0;
          // color persists in nextR/G/B (already copied)
        }else{
          if(sum===3){
            nextGrid[i]=1;
            if(chkRainbow.checked){
              // average exactly the 3 neighbors (list length is 3 here)
              let ar=0,ag=0,ab=0;
              for(let k=0;k<3;k++){const j=list[k]; ar+=colR[j]; ag+=colG[j]; ab+=colB[j];}
              nextR[i]=Math.round(ar/3); nextG[i]=Math.round(ag/3); nextB[i]=Math.round(ab/3);
            }else{
              const [fr,fg,fb]=getFillRGB(); nextR[i]=fr; nextG[i]=fg; nextB[i]=fb;
            }
          }else{
            nextGrid[i]=0; // remains dead
          }
        }
      }}
    }

    function wrapOrBound(r,c){
      if(chkToroidal.checked){if(r<0)r=rows-1;else if(r>=rows)r=0; if(c<0)c=cols-1;else if(c>=cols)c=0; return {r,c,out:false};}
      else{if(r<0||r>=rows||c<0||c>=cols)return {r,c,out:true}; return {r,c,out:false};}
    }
    const indexAt=(r,c)=>r*cols+c;
    function ringPositions(centerIndex,radius){
      const cr=Math.floor(centerIndex/cols);const cc=centerIndex%cols;const pos=[];
      for(let dr=-radius;dr<=radius;dr++){for(let dc=-radius;dc<=radius;dc++){if(Math.max(Math.abs(dr),Math.abs(dc))!==radius)continue;
        let rr=cr+dr,cc2=cc+dc;const wp=wrapOrBound(rr,cc2);if(wp.out)continue;rr=wp.r;cc2=wp.c;pos.push(indexAt(rr,cc2));}}
      return pos;
    }
    function spawnOneAtIncreasingRadius(centerIndex,emptyFlagArr){
      const maxR=Math.max(rows,cols);
      for(let radius=1;radius<=maxR;radius++){
        const ring=ringPositions(centerIndex,radius);
        if(ring.length===0)continue;
        const j=ring[(Math.random()*ring.length)|0];
        if(emptyFlagArr[j])return j;
      } return -1;
    }

    function getLivePct(){const total=rows*cols;return total?(countLive()/total)*100:0;}
    function getBR(){const v=Math.floor(Number(inputBirthRate.value));return (!isFinite(v)||v<0)?0:v;}
    function agingRespawnCount(){
      if(!chkAging.checked)return 0;
      const BR=getBR();
      if(chkPopRebal.checked){
        const cur=getLivePct();const target=clamp(parseFloat(inputFillPercent.value),0,100);const thr=clamp(parseFloat(inputRebalThreshold.value),0,100);
        if(cur<target-thr)return BR+1;
        if(cur>target+thr)return Math.max(0,BR-1);
        return BR;
      } else return BR;
    }
    function immediateNeighborAverageColorAt(index){
      const r=Math.floor(index/cols), c=index%cols;
      const {sum,list}=neighborCountAndList(r,c);
      if(sum===0) return null;
      let ar=0,ag=0,ab=0;
      for(let k=0;k<list.length;k++){const j=list[k]; ar+=colR[j]; ag+=colG[j]; ab+=colB[j];}
      return [Math.round(ar/list.length), Math.round(ag/list.length), Math.round(ab/list.length)];
    }
    function applyAgingIfNeeded(){
      if(!chkAging.checked)return;
      if(history.length<Math.max(1,historyCap-1))return;
      const windowLen=Math.min(historyCap-1,history.length);
      const snaps=[];for(let k=0;k<windowLen;k++)snaps.push(history[cursor-k]);
      const total=rows*cols;const toKill=[];
      for(let i=0;i<total;i++){if(grid[i]!==1)continue; let allAlive=true;
        for(let s=0;s<snaps.length;s++){if(snaps[s].grid[i]!==1){allAlive=false;break;}} if(allAlive)toKill.push(i);}
      if(toKill.length===0)return;
      const emptyFlag=new Array(total);for(let i=0;i<total;i++)emptyFlag[i]=(grid[i]===0);
      const respawnsPerDeath=agingRespawnCount();
      const [fr0,fg0,fb0]=getFillRGB();
      for(const i of toKill){
        const diedR=colR[i], diedG=colG[i], diedB=colB[i];
        if(grid[i]===1){grid[i]=0; emptyFlag[i]=true;}
        for(let k=0;k<respawnsPerDeath;k++){
          const j=spawnOneAtIncreasingRadius(i,emptyFlag);
          if(j<0) break;
          grid[j]=1;
          if(chkRainbow.checked){
            const avg = immediateNeighborAverageColorAt(j);
            if(avg){ colR[j]=avg[0]; colG[j]=avg[1]; colB[j]=avg[2]; }
            else { colR[j]=diedR; colG[j]=diedG; colB[j]=diedB; }
          }else{
            colR[j]=fr0; colG[j]=fg0; colB[j]=fb0;
          }
          emptyFlag[j]=false;
        }
      }
    }

    function stepForwardComputeAndMutations(){
      computeNextGeneration();
      // swap
      let tmp=grid; grid=nextGrid; nextGrid=tmp;
      tmp=colR; colR=nextR; nextR=tmp;
      tmp=colG; colG=nextG; nextG=tmp;
      tmp=colB; colB=nextB; nextB=tmp;
      generation+=1;
      applyAgingIfNeeded();
      draw();
      updateStatus();
    }
    function snapshotIfDirty(){ if(dirtySinceSnapshot){ pushHistorySnapshot(); } }
    function stepForwardUser(){
      if(!canStepForwardRedo()){
        snapshotIfDirty(); // capture current manual edits before advancing
        stepForwardComputeAndMutations();
        pushHistorySnapshot();
      } else {
        loadHistoryAt(cursor+1);
      }
    }
    function stepBackUser(){ if(!canStepBack()) return; loadHistoryAt(cursor-1); }

    const lerp=(a,b,t)=>a+(b-a)*t;
    const stops=[{p:0.00,c:[255,255,255]},{p:0.15,c:[207,232,255]},{p:0.30,c:[0,180,180]},{p:0.50,c:[0,192,0]},{p:0.75,c:[255,212,0]},{p:1.00,c:[255,0,0]}];
    function colorFromFrac(frac){
      let f=Math.max(0,Math.min(1,frac)); if(f===0)return 'rgb(255,255,255)';
      for(let i=0;i<stops.length-1;i++){const a=stops[i],b=stops[i+1]; if(f>=a.p&&f<=b.p){const t=(f-a.p)/(b.p-a.p);
        const r=Math.round(lerp(a.c[0],b.c[0],t)),g=Math.round(lerp(a.c[1],b.c[1],t)),bb=Math.round(lerp(a.c[2],b.c[2],t)); return `rgb(${r},${g},${bb})`;}}
      const last=stops[stops.length-1].c; return `rgb(${last[0]},${last[1]},${last[2]})`;
    }
    function drawTrendsLegend(x,y,w,h){
      const grad = ctx.createLinearGradient(x, y, x+w, y);
      grad.addColorStop(0, 'rgb(255,255,255)');
      grad.addColorStop(0.15, 'rgb(207,232,255)');
      grad.addColorStop(0.30, 'rgb(0,180,180)');
      grad.addColorStop(0.50, 'rgb(0,192,0)');
      grad.addColorStop(0.75, 'rgb(255,212,0)');
      grad.addColorStop(1, 'rgb(255,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(x,y,w,h);
      ctx.strokeStyle='#333'; ctx.strokeRect(x,y,w,h);
      ctx.fillStyle='#111'; ctx.font='10px system-ui, sans-serif';
      ctx.textBaseline='top';
      const ticks=[0,25,50,75,100];
      for(const t of ticks){
        const tx=x+Math.round((t/100)*w);
        ctx.beginPath(); ctx.moveTo(tx,y+h); ctx.lineTo(tx,y+h+4); ctx.stroke();
        const text=String(t)+'%';
        const tw=ctx.measureText(text).width;
        ctx.fillText(text, Math.min(Math.max(tx - tw/2, x), x+w-tw), y+h+4);
      }
      ctx.fillStyle='#111'; ctx.font='11px system-ui, sans-serif';
      ctx.fillText('Trends', x, y-12);
    }
    function draw(){
      const rainbowOn=chkRainbow.checked;
      const wantTrends=chkTrends.checked;
      const knownStates=cursor+1;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(wantTrends&&knownStates>1){
        for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){const i=idx(r,c);let aliveCount=0;for(let k=0;k<knownStates;k++){aliveCount+=history[cursor-k].grid[i];}
          ctx.fillStyle=colorFromFrac(aliveCount/knownStates); ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize);}}
        const pad=8, w=160, h=10;
        drawTrendsLegend(pad, canvas.height - pad - 24, w, h);
      } else if(rainbowOn){
        for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){const i=idx(r,c); if(grid[i]){ctx.fillStyle=`rgb(${colR[i]},${colG[i]},${colB[i]})`; ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize);}}}
      } else {
        if(chkBWColor.checked){
          for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){const i=idx(r,c); if(grid[i]){ctx.fillStyle=`rgb(${colR[i]},${colG[i]},${colB[i]})`; ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize);}}}
        }else{
          ctx.fillStyle='#111';
          for(let r=0;r<rows;r++){for(let c=0;c<cols;c++){if(grid[idx(r,c)])ctx.fillRect(c*blockSize,r*blockSize,blockSize,blockSize);}}
        }
      }
      if(blockSize>=16){
        ctx.strokeStyle='#eee';ctx.lineWidth=1;
        for(let c=0;c<=cols;c++){const x=c*blockSize+.5;ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,rows*blockSize);ctx.stroke();}
        for(let r=0;r<=rows;r++){const y=r*blockSize+.5;ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cols*blockSize,y);ctx.stroke();}
      }
    }

    function randomIndicesInRegion(count,region){
      const r0=region.r0,r1=region.r1,c0=region.c0,c1=region.c1;
      const regionCells=(r1-r0+1)*(c1-c0+1);
      count=Math.max(0,Math.min(count,regionCells));
      const chosen=new Set();
      while(chosen.size<count){
        const rr=r0+((Math.random()*(r1-r0+1))|0);
        const cc=c0+((Math.random()*(c1-c0+1))|0);
        chosen.add(rr*cols+cc);
      }
      return chosen;
    }
    function fillRegionPct(pct,region){
      const r0=region.r0,r1=region.r1,c0=region.c0,c1=region.c1;
      if(r1<r0||c1<c0)return;
      const regionCells=(r1-r0+1)*(c1-c0+1);
      const toActivate=Math.round((pct/100)*regionCells);
      if(toActivate<=0)return;
      const picks=randomIndicesInRegion(toActivate,region);
      const [fr,fg,fb]=getFillRGB();
      for(const i of picks){grid[i]=1; colR[i]=fr; colG[i]=fg; colB[i]=fb;}
      dirtySinceSnapshot=true;
    }
    function doFillDirectional(which){
      const pctRaw=parseFloat(inputFillPercent.value);
      const pct=clamp(isFinite(pctRaw)?pctRaw:0,0,100);
      const midRow=Math.floor(rows/2);
      const midCol=Math.floor(cols/2);
      const regions={
        up:{r0:0,r1:Math.max(0,midRow-1),c0:0,c1:cols-1},
        down:{r0:midRow,r1:rows-1,c0:0,c1:cols-1},
        left:{r0:0,r1:rows-1,c0:0,c1:Math.max(0,midCol-1)},
        right:{r0:0,r1:rows-1,c0:midCol,c1:cols-1},
        center:{r0:0,r1:rows-1,c0:0,c1:cols-1},
        nw:{r0:0,r1:Math.max(0,midRow-1),c0:0,c1:Math.max(0,midCol-1)},
        ne:{r0:0,r1:Math.max(0,midRow-1),c0:midCol,c1:cols-1},
        sw:{r0:midRow,r1:rows-1,c0:0,c1:Math.max(0,midCol-1)},
        se:{r0:midRow,r1:rows-1,c0:midCol,c1:cols-1},
      };
      const region=regions[which];
      if(!region||region.r1<region.r0||region.c1<region.c0)return;
      pushHistorySnapshot(); // snapshot BEFORE fill to allow immediate undo
      fillRegionPct(pct,region);
      draw();updateStatus();
    }
    function doClear(){
      grid.fill(0);generation=0;history=[];cursor=-1;lastFPS=0;lastTickTime=null;dirtySinceSnapshot=false;
      pushHistorySnapshot();draw();updateStatus();
    }

    function tick(time){
      if(!running)return;
      if(lastTickTime!=null){
        const dt=time-lastTickTime;
        if(dt>0) lastFPS = 1000/dt;
      }
      lastTickTime=time;
      stepForwardComputeAndMutations();
      pushHistorySnapshot();
      rafId=requestAnimationFrame(tick);
    }
    function startPlay(){if(running)return;if(rafId)cancelAnimationFrame(rafId);setControlsForRunning(true);rafId=requestAnimationFrame(tick);}
    function pausePlay(){if(!running)return;setControlsForRunning(false);if(rafId){cancelAnimationFrame(rafId);rafId=null;} /* keep lastFPS as-is */}

    function eventToCell(ev){const rect=canvas.getBoundingClientRect();const x=ev.clientX-rect.left;const y=ev.clientY-rect.top;const c=Math.floor(x/blockSize);const r=Math.floor(y/blockSize);if(r<0||r>=rows||c<0||c>=cols)return null;return {r,c,i:idx(r,c)};}
    function handlePointerDown(ev){
      const cell=eventToCell(ev);if(!cell)return;
      const current=grid[cell.i];const target=current?0:1;dragState=target;
      if(grid[cell.i]!==target){grid[cell.i]=target; if(target===1){const [fr,fg,fb]=getFillRGB(); colR[cell.i]=fr; colG[cell.i]=fg; colB[cell.i]=fb;} dirtySinceSnapshot=true; draw();updateStatus();}
      window.addEventListener('pointermove',handlePointerMove);
      window.addEventListener('pointerup',handlePointerUp,{once:true});
      canvas.setPointerCapture&&canvas.setPointerCapture(ev.pointerId||1);
    }
    function handlePointerMove(ev){
      if(dragState===null)return;
      const cell=eventToCell(ev);if(!cell)return;
      if(grid[cell.i]!==dragState){grid[cell.i]=dragState; if(dragState===1){const [fr,fg,fb]=getFillRGB(); colR[cell.i]=fr; colG[cell.i]=fg; colB[cell.i]=fb;} dirtySinceSnapshot=true; draw();updateStatus();}
    }
    function handlePointerUp(_ev){
      dragState=null;window.removeEventListener('pointermove',handlePointerMove);
      if(dirtySinceSnapshot){ pushHistorySnapshot(); } // snapshot drawn shape
    }

    function syncEnabledStates(){
      const agingOn=chkAging.checked;
      inputBirthRate.disabled=!agingOn;
      document.getElementById('birthRateRow').classList.toggle('disabled-field',!agingOn);
      const popOn=agingOn&&chkPopRebal.checked;
      inputRebalThreshold.disabled=!popOn;
      document.getElementById('thresholdRow').classList.toggle('disabled-field',!popOn);
      chkPopRebal.closest('.checkbox-row').classList.toggle('disabled-field',!agingOn);
    }

    function init(){
      blockSize=clamp(parseInt(inputBlockSize.value,10)||3,1,4096); inputBlockSize.value=String(blockSize);
      historyCap=clamp(parseInt(inputHistoryCap.value,10)||10,1,500); inputHistoryCap.value=String(historyCap);
      resizeGridToFit(false);
      const total=rows*cols;
      if(total>0){const picks=Math.round(0.30*total);const chosen=new Set();const [fr,fg,fb]=getFillRGB();while(chosen.size<picks)chosen.add((Math.random()*total)|0);for(const i of chosen){grid[i]=1; colR[i]=fr; colG[i]=fg; colB[i]=fb;}}
      generation=0; lastFPS=0; lastTickTime=null; resetHistory(); pushHistorySnapshot();
      document.getElementById('statTopology').textContent=chkToroidal.checked?'Toroidal':'Bounded';
      syncEnabledStates(); draw(); updateStatus();
    }

    btnPlay.addEventListener('click',startPlay);
    btnPause.addEventListener('click',pausePlay);
    btnStepForward.addEventListener('click',()=>{if(!running)stepForwardUser();});
    btnStepBack.addEventListener('click',()=>{if(!running)stepBackUser();});
    btnFillUp.addEventListener('click',()=>{doFillDirectional('up');});
    btnFillDown.addEventListener('click',()=>{doFillDirectional('down');});
    btnFillLeft.addEventListener('click',()=>{doFillDirectional('left');});
    btnFillRight.addEventListener('click',()=>{doFillDirectional('right');});
    btnFillCenter.addEventListener('click',()=>{doFillDirectional('center');});
    btnFillNW.addEventListener('click',()=>{doFillDirectional('nw');});
    btnFillNE.addEventListener('click',()=>{doFillDirectional('ne');});
    btnFillSW.addEventListener('click',()=>{doFillDirectional('sw');});
    btnFillSE.addEventListener('click',()=>{doFillDirectional('se');});
    btnClear.addEventListener('click',()=>{if(!running){doClear();}});
    btnResizeFit.addEventListener('click',()=>{if(!running)resizeGridToFit(true);});
    inputBlockSize.addEventListener('change',()=>{const v=Math.floor(Number(inputBlockSize.value));if(!isFinite(v)||v<1){inputBlockSize.value=String(blockSize);return;}blockSize=v;resizeGridToFit(true);});
    inputHistoryCap.addEventListener('change',()=>{const v=Math.floor(Number(inputHistoryCap.value));if(!isFinite(v)||v<1){inputHistoryCap.value=String(historyCap);return;}historyCap=clamp(v,1,500);inputHistoryCap.value=String(historyCap);enforceHistoryCap();draw();});
    chkToroidal.addEventListener('change',()=>{updateStatus();draw();});
    [chkRainbow,chkTrends,chkAging,chkPopRebal,chkBWColor].forEach(el=>el.addEventListener('change',()=>{syncEnabledStates();draw();}));
    window.addEventListener('resize',()=>{});
    canvas.addEventListener('pointerdown',handlePointerDown);

    window.addEventListener('keydown', (e)=>{
      const tag=(e.target && e.target.tagName)||'';
      const editable = (e.target && (e.target.isContentEditable || tag==='INPUT' || tag==='TEXTAREA' || tag==='SELECT'));
      if(editable) return;
      if(e.code==='Space'){ e.preventDefault(); running?pausePlay():startPlay(); }
      else if(e.code==='ArrowLeft'){ e.preventDefault(); if(!running) stepBackUser(); }
      else if(e.code==='ArrowRight'){ e.preventDefault(); if(!running) stepForwardUser(); }
    });

    init();
  })();
  </script>
</body>
</html>