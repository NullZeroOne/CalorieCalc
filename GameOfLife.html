<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Conway's Game of Life</title>
  <style>
    :root {
      --panel-bg: #f6f7f9;
      --panel-border: #e1e4e8;
      --accent: #2f6feb;
      --text: #111;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .app {
      height: 100vh;
      display: flex;
      overflow: hidden;
    }
    .controls {
      width: 360px;
      max-width: 46vw;
      background: var(--panel-bg);
      border-right: 1px solid var(--panel-border);
      padding: 16px;
      overflow-y: auto;
    }
    .controls h1 {
      font-size: 18px;
      margin: 0 0 12px 0;
    }
    .group {
      margin-bottom: 14px;
      padding-bottom: 12px;
      border-bottom: 1px dashed var(--panel-border);
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
      flex-wrap: wrap;
    }
    label { font-size: 14px; }
    input[type="number"] {
      width: 120px;
      padding: 6px 8px;
      border: 1px solid var(--panel-border);
      border-radius: 6px;
      font-size: 14px;
    }
    input[type="checkbox"] {
      transform: translateY(1px);
      width: 16px; height: 16px;
    }
    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: white;
      font-size: 14px;
      cursor: pointer;
    }
    button.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .status {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 10px;
      font-size: 13px;
    }
    .status div { white-space: nowrap; }
    .board-wrap {
      position: relative;
      flex: 1;
      overflow: auto;
      background: #fff;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      background: #ffffff;
    }
    .board-disabled {
      pointer-events: none;
      opacity: 0.9;
    }
    .hint {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="controls" aria-label="Controls">
      <h1>Conway's Game of Life</h1>

      <div class="group" aria-label="Playback controls">
        <div class="row">
          <button id="btnPlay" class="primary" title="Play">Play</button>
          <button id="btnPause" title="Pause">Pause</button>
        </div>
        <div class="row">
          <button id="btnStepBack" title="Step back">⟵ Step Back</button>
          <button id="btnStepForward" title="Step forward">Step Forward ⟶</button>
        </div>
        <div class="row">
          <label for="inputMaxSpeed" title="Maximum moves per second while playing">Max speed (moves/s)</label>
          <input id="inputMaxSpeed" type="number" step="0.1" min="0.1" value="60" />
        </div>
        <div class="hint">During Play, all inputs are disabled except Pause.</div>
      </div>

      <div class="group" aria-label="Grid & history settings">
        <div class="row">
          <label for="chkToroidal">Toroidal topology</label>
          <input id="chkToroidal" type="checkbox" />
        </div>
        <div class="row">
          <label for="chkTrends" title="Show grayscale trend of activity using current + available previous saved states.">Trends</label>
          <input id="chkTrends" type="checkbox" />
        </div>
        <div class="row">
          <label for="chkAutoDie" title="If enabled and the history window is full, cells alive for the entire window will die and spawn the same number of random new cells.">AutoDie</label>
          <input id="chkAutoDie" type="checkbox" />
        </div>
        <div class="row">
          <label for="inputHistoryCap" title="Number of board states to keep in history (undo/redo window).">History size</label>
          <input id="inputHistoryCap" type="number" min="1" max="500" step="1" value="10" />
        </div>
        <div class="row">
          <label for="inputBlockSize">Block size (px)</label>
          <input id="inputBlockSize" type="number" min="1" step="1" value="10" />
        </div>
        <div class="row">
          <button id="btnResizeFit" title="Resize grid to fit available area with current block size">Resize to Fit</button>
        </div>
      </div>

      <div class="group" aria-label="Fill & clear">
        <div class="row">
          <label for="inputFillPercent">Fill %</label>
          <input id="inputFillPercent" type="number" min="0" max="100" step="1" value="30" />
          <button id="btnFill">Fill</button>
        </div>
        <div class="row">
          <button id="btnClear">Clear</button>
        </div>
      </div>

      <div class="group" aria-label="Status">
        <div class="status">
          <div><strong>Generation:</strong> <span id="statGeneration">0</span></div>
          <div><strong>Live cells:</strong> <span id="statLive">0</span></div>
          <div><strong>Grid:</strong> <span id="statSize">0×0</span></div>
          <div><strong>Topology:</strong> <span id="statTopology">Bounded</span></div>
        </div>
        <div class="hint">Tip: Click a cell to toggle. Drag continues the last action.</div>
      </div>
    </aside>

    <main class="board-wrap">
      <canvas id="board" aria-label="Game board"></canvas>
    </main>
  </div>

  <script>
  (() => {
    // ====== State ======
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d', { alpha: false });

    const btnPlay = document.getElementById('btnPlay');
    const btnPause = document.getElementById('btnPause');
    const btnStepForward = document.getElementById('btnStepForward');
    const btnStepBack = document.getElementById('btnStepBack');
    const btnFill = document.getElementById('btnFill');
    const btnClear = document.getElementById('btnClear');
    const btnResizeFit = document.getElementById('btnResizeFit');
    const inputFillPercent = document.getElementById('inputFillPercent');
    const inputBlockSize = document.getElementById('inputBlockSize');
    const inputMaxSpeed = document.getElementById('inputMaxSpeed');
    const inputHistoryCap = document.getElementById('inputHistoryCap');
    const chkToroidal = document.getElementById('chkToroidal');
    const chkTrends = document.getElementById('chkTrends');
    const chkAutoDie = document.getElementById('chkAutoDie');

    const statGeneration = document.getElementById('statGeneration');
    const statLive = document.getElementById('statLive');
    const statSize = document.getElementById('statSize');
    const statTopology = document.getElementById('statTopology');
    const boardWrap = document.querySelector('.board-wrap');

    let historyCap = 10; // user-configurable

    let rows = 0, cols = 0;
    let blockSize = 10;
    let grid = new Uint8Array(0);
    let nextGrid = new Uint8Array(0);
    let generation = 0;
    let running = false;
    let playTimer = null;
    let history = []; // array of {grid: Uint8Array, generation: number}
    let cursor = -1;  // index in history of current state
    let dragState = null; // null | 0 | 1

    // ====== Utilities ======
    function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }
    function idx(r,c) { return r * cols + c; }

    function setCanvasSizeToGrid() {
      canvas.width = cols * blockSize;
      canvas.height = rows * blockSize;
    }

    function computeFitGridDimensions() {
      const rect = boardWrap.getBoundingClientRect();
      const w = Math.max(0, Math.floor(rect.width));
      const h = Math.max(0, Math.floor(rect.height));
      const newCols = Math.max(1, Math.floor(w / blockSize));
      const newRows = Math.max(1, Math.floor(h / blockSize));
      return { newRows, newCols };
    }

    function resizeGridToFit(keepIntersection = true) {
      const { newRows, newCols } = computeFitGridDimensions();
      if (newRows === rows && newCols === cols) return;

      const newGrid = new Uint8Array(newRows * newCols);
      if (keepIntersection && grid.length) {
        const cr = Math.min(rows, newRows);
        const cc = Math.min(cols, newCols);
        for (let r = 0; r < cr; r++) {
          for (let c = 0; c < cc; c++) {
            newGrid[r * newCols + c] = grid[idx(r,c)];
          }
        }
      }
      rows = newRows; cols = newCols;
      grid = newGrid;
      nextGrid = new Uint8Array(rows * cols);
      setCanvasSizeToGrid();
      // Dimension change invalidates history snapshots
      resetHistory();
      draw();
      updateStatus();
    }

    function resetHistory() {
      history = [];
      cursor = -1;
      pushHistorySnapshot(); // snapshot current grid as starting point
      updateHistoryButtons();
    }

    function enforceHistoryCap() {
      // Remove oldest while exceeding cap; shift cursor accordingly
      while (history.length > historyCap) {
        history.shift();
        cursor = Math.max(0, cursor - 1);
      }
      updateHistoryButtons();
    }

    function pushHistorySnapshot(customGrid=null, customGeneration=null) {
      // Truncate any redo states
      if (cursor < history.length - 1) {
        history = history.slice(0, cursor + 1);
      }
      const snapGrid = (customGrid ? customGrid : grid).slice(0);
      const snapGen = (customGeneration !== null ? customGeneration : generation);
      history.push({ grid: snapGrid, generation: snapGen });
      enforceHistoryCap();
      cursor = history.length - 1;
      updateHistoryButtons();
    }

    function canStepBack() { return cursor > 0; }
    function canStepForwardRedo() { return cursor < history.length - 1; }

    function loadHistoryAt(newCursor) {
      if (newCursor < 0 || newCursor >= history.length) return;
      cursor = newCursor;
      const snap = history[cursor];
      if (snap.grid.length !== grid.length) {
        grid = snap.grid.slice(0);
      } else {
        grid.set(snap.grid);
      }
      generation = snap.generation;
      draw();
      updateStatus();
      updateHistoryButtons();
    }

    function updateHistoryButtons() {
      btnStepBack.disabled = !canStepBack() || running;
      btnStepForward.disabled = running;
    }

    function setControlsForRunning(isRunning) {
      running = isRunning;
      // Disable everything except Pause when running
      const allInputs = [
        btnPlay, btnStepForward, btnStepBack, btnFill, btnClear, btnResizeFit,
        inputFillPercent, inputBlockSize, inputMaxSpeed, inputHistoryCap, chkToroidal, chkTrends, chkAutoDie
      ];
      for (const el of allInputs) el.disabled = isRunning;

      // Play button should be disabled while running; Pause enabled only while running
      btnPlay.disabled = isRunning;
      btnPause.disabled = !isRunning;

      // Board interactions disabled while running
      canvas.classList.toggle('board-disabled', isRunning);

      // History buttons reflect running state
      updateHistoryButtons();
    }

    function updateStatus() {
      statGeneration.textContent = String(generation);
      statSize.textContent = cols + '×' + rows;
      statTopology.textContent = chkToroidal.checked ? 'Toroidal' : 'Bounded';
      statLive.textContent = String(countLive());
    }

    function countLive() {
      let n = 0;
      for (let i = 0; i < grid.length; i++) n += grid[i];
      return n;
    }

    // ====== Game Logic ======
    function neighborCount(r, c) {
      let sum = 0;
      const tor = chkToroidal.checked;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          let rr = r + dr, cc = c + dc;
          if (tor) {
            if (rr < 0) rr = rows - 1; else if (rr >= rows) rr = 0;
            if (cc < 0) cc = cols - 1; else if (cc >= cols) cc = 0;
            sum += grid[idx(rr, cc)];
          } else {
            if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
            sum += grid[idx(rr, cc)];
          }
        }
      }
      return sum;
    }

    function computeNextGeneration(out) {
      // out must be a Uint8Array of size rows*cols
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const i = idx(r,c);
          const n = neighborCount(r,c);
          const alive = grid[i] === 1;
          out[i] = alive ? ((n === 2 || n === 3) ? 1 : 0) : (n === 3 ? 1 : 0);
        }
      }
    }

    function applyAutoDieIfNeeded() {
      if (!chkAutoDie.checked) return;
      // We want a full window of size 'historyCap' consisting of previous (historyCap-1) snapshots plus current grid.
      if (history.length < Math.max(1, historyCap - 1)) return; // not enough past states
      // Build a list of indices that have been alive in ALL states of the window.
      const windowLen = Math.min(historyCap - 1, history.length); // number of previous snapshots to include
      const total = rows * cols;
      // Precompute an array of references to the previous snapshots we're considering
      const snaps = [];
      for (let k = 0; k < windowLen; k++) {
        snaps.push(history[cursor - k]); // cursor points to last snapshot before current step
      }
      const toKill = [];
      // Identify persistent-alive cells across (windowLen previous) + current
      for (let i = 0; i < total; i++) {
        if (grid[i] !== 1) continue; // current must be alive
        let allAlive = true;
        for (let s = 0; s < snaps.length; s++) {
          if (snaps[s].grid[i] !== 1) { allAlive = false; break; }
        }
        if (allAlive) toKill.push(i);
      }
      if (toKill.length === 0) return;

      // Prepare a list of empty indices to choose from; we'll update as we place new cells
      const empties = [];
      for (let i = 0; i < total; i++) if (grid[i] === 0) empties.push(i);

      function pickRandomEmptyAndActivate() {
        if (empties.length === 0) return; // no space
        const pos = (Math.random() * empties.length) | 0;
        const j = empties[pos];
        grid[j] = 1;
        // remove from empties
        empties[pos] = empties[empties.length - 1];
        empties.pop();
      }

      // Apply: kill each qualifying cell, and spawn one random empty
      for (const i of toKill) {
        grid[i] = 0;
        empties.push(i); // freed up; now empty and eligible
        pickRandomEmptyAndActivate();
      }
    }

    function stepForwardComputeAndMaybeAutoDie() {
      // Compute nextGrid from grid, then swap (producing the new "current" grid)
      computeNextGeneration(nextGrid);
      const tmp = grid;
      grid = nextGrid;
      nextGrid = tmp;
      generation += 1;

      // Apply AutoDie using current grid and previous snapshots
      applyAutoDieIfNeeded();

      draw();
      updateStatus();
    }

    function stepForwardUser() {
      // If there is redo, go forward in history (do NOT recompute or re-apply AutoDie)
      if (canStepForwardRedo()) {
        loadHistoryAt(cursor + 1);
      } else {
        // Compute a new generation (+ optional AutoDie) and push to history
        stepForwardComputeAndMaybeAutoDie();
        pushHistorySnapshot();
      }
    }

    function stepBackUser() {
      if (!canStepBack()) return;
      loadHistoryAt(cursor - 1);
    }

    // ====== Rendering ======
    function drawTrendsOrBW() {
      const wantTrends = chkTrends.checked;
      const knownStates = cursor + 1; // number of snapshots from history[0..cursor] inclusive
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!wantTrends || knownStates <= 1) {
        // Standard black/white render using current grid
        ctx.fillStyle = '#111';
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (grid[idx(r,c)]) {
              ctx.fillRect(c * blockSize, r * blockSize, blockSize, blockSize);
            }
          }
        }
      } else {
        // Trends render: intensity based on fraction of alive over knownStates (current + available past)
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const i = idx(r,c);
            let aliveCount = 0;
            for (let k = 0; k < knownStates; k++) {
              const snap = history[cursor - k];
              aliveCount += snap.grid[i];
            }
            const frac = aliveCount / knownStates; // 0..1
            const g = Math.round(255 * (1 - frac)); // 0=black (always alive), 255=white (never alive)
            ctx.fillStyle = `rgb(${g},${g},${g})`;
            ctx.fillRect(c * blockSize, r * blockSize, blockSize, blockSize);
          }
        }
      }

      // Optional grid lines for large blocks
      if (blockSize >= 16) {
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 1;
        // verticals
        for (let c = 0; c <= cols; c++) {
          const x = c * blockSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, rows * blockSize);
          ctx.stroke();
        }
        // horizontals
        for (let r = 0; r <= rows; r++) {
          const y = r * blockSize + 0.5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cols * blockSize, y);
          ctx.stroke();
        }
      }
    }

    function draw() {
      drawTrendsOrBW();
    }

    // ====== Fill & Clear ======
    function doFill() {
      // Push pre-fill snapshot so one Step Back restores prior board
      pushHistorySnapshot();
      const pctRaw = parseFloat(inputFillPercent.value);
      const pct = clamp(isFinite(pctRaw) ? pctRaw : 0, 0, 100);
      inputFillPercent.value = String(Math.round(pct));
      const total = rows * cols;
      const target = Math.round((pct / 100) * total);
      grid.fill(0);
      if (target > 0) {
        if (target * 3 < total) {
          const chosen = new Set();
          while (chosen.size < target) {
            chosen.add((Math.random() * total) | 0);
          }
          for (const i of chosen) grid[i] = 1;
        } else {
          grid.fill(1);
          let toZero = total - target;
          const chosen = new Set();
          while (chosen.size < toZero) {
            chosen.add((Math.random() * total) | 0);
          }
          for (const i of chosen) grid[i] = 0;
        }
      }
      generation = 0; // treat as fresh board
      // Push post-fill snapshot
      pushHistorySnapshot();
      draw();
      updateStatus();
    }

    function doClear() {
      // Push pre-clear snapshot
      pushHistorySnapshot();
      grid.fill(0);
      generation = 0;
      // Push post-clear snapshot
      pushHistorySnapshot();
      draw();
      updateStatus();
    }

    // ====== Play Loop ======
    function getDesiredDelayMs() {
      const v = parseFloat(inputMaxSpeed.value);
      const movesPerSec = isFinite(v) && v > 0 ? v : 60;
      return 1000 / movesPerSec;
    }

    function dropRedoIfAny() {
      if (cursor < history.length - 1) {
        history = history.slice(0, cursor + 1);
      }
    }

    function tick() {
      if (!running) return;
      const t0 = performance.now();

      // Each tick is exactly one generation (+ optional AutoDie)
      stepForwardComputeAndMaybeAutoDie();
      pushHistorySnapshot();

      const elapsed = performance.now() - t0;
      const delay = Math.max(0, getDesiredDelayMs() - elapsed);
      playTimer = setTimeout(tick, delay);
    }

    function startPlay() {
      if (running) return;
      dropRedoIfAny();
      setControlsForRunning(true);
      tick();
    }

    function pausePlay() {
      if (!running) return;
      setControlsForRunning(false);
      if (playTimer) {
        clearTimeout(playTimer);
        playTimer = null;
      }
    }

    // ====== Board Editing (click-to-toggle, drag continues last action) ======
    function eventToCell(ev) {
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      const c = Math.floor(x / blockSize);
      const r = Math.floor(y / blockSize);
      if (r < 0 || r >= rows || c < 0 || c >= cols) return null;
      return { r, c, i: idx(r,c) };
    }

    function handlePointerDown(ev) {
      if (running) return; // disabled during play
      const cell = eventToCell(ev);
      if (!cell) return;
      const current = grid[cell.i];
      const target = current ? 0 : 1;
      dragState = target;
      if (grid[cell.i] !== target) {
        grid[cell.i] = target;
        draw();
        updateStatus();
      }
      window.addEventListener('pointermove', handlePointerMove);
      window.addEventListener('pointerup', handlePointerUp, { once: true });
      canvas.setPointerCapture && canvas.setPointerCapture(ev.pointerId || 1);
    }

    function handlePointerMove(ev) {
      if (dragState === null) return;
      const cell = eventToCell(ev);
      if (!cell) return;
      if (grid[cell.i] !== dragState) {
        grid[cell.i] = dragState;
        draw();
        updateStatus();
      }
    }

    function handlePointerUp(_ev) {
      dragState = null;
      window.removeEventListener('pointermove', handlePointerMove);
    }

    // ====== Initialization ======
    function init() {
      blockSize = clamp(parseInt(inputBlockSize.value, 10) || 10, 1, 4096);
      inputBlockSize.value = String(blockSize);

      historyCap = clamp(parseInt(inputHistoryCap.value, 10) || 10, 1, 500);
      inputHistoryCap.value = String(historyCap);

      // Initial grid fills available area after leaving space for UI
      resizeGridToFit(false);
      // Start with empty board and snapshot initial state
      grid.fill(0);
      generation = 0;
      resetHistory();
      draw();
      updateStatus();
    }

    // ====== Event wiring ======
    btnPlay.addEventListener('click', startPlay);
    btnPause.addEventListener('click', pausePlay);
    btnStepForward.addEventListener('click', () => {
      if (running) return;
      stepForwardUser();
    });
    btnStepBack.addEventListener('click', () => {
      if (running) return;
      stepBackUser();
    });

    btnFill.addEventListener('click', () => {
      if (running) return;
      // Filling after stepping back truncates redo
      dropRedoIfAny();
      doFill();
    });

    btnClear.addEventListener('click', () => {
      if (running) return;
      dropRedoIfAny();
      doClear();
    });

    btnResizeFit.addEventListener('click', () => {
      if (running) return;
      resizeGridToFit(true);
    });

    inputBlockSize.addEventListener('change', () => {
      if (running) return;
      const v = Math.floor(Number(inputBlockSize.value));
      if (!isFinite(v) || v < 1) {
        inputBlockSize.value = String(blockSize);
        return;
      }
      blockSize = v;
      // Changing block size recomputes grid to fit
      resizeGridToFit(true);
    });

    inputHistoryCap.addEventListener('change', () => {
      if (running) return;
      const v = Math.floor(Number(inputHistoryCap.value));
      if (!isFinite(v) || v < 1) {
        inputHistoryCap.value = String(historyCap);
        return;
      }
      historyCap = clamp(v, 1, 500);
      inputHistoryCap.value = String(historyCap);
      enforceHistoryCap();
      draw(); // trends may change with different window length available
    });

    chkToroidal.addEventListener('change', () => {
      updateStatus(); // takes effect on next evolution step
      draw(); // redraw in case trends
    });

    chkTrends.addEventListener('change', () => {
      draw(); // toggle between BW and Trends
    });

    chkAutoDie.addEventListener('change', () => {
      // No immediate effect; applies on next computed generation
    });

    // Keep logical grid size stable on window resize (manual recompute via button)
    window.addEventListener('resize', () => {
      // no automatic recompute
    });

    // Board interactions
    canvas.addEventListener('pointerdown', handlePointerDown);

    // Kick off
    init();
  })();
  </script>
</body>
</html>
